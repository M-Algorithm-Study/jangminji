# 2주차
## 공통 문제
> [백준 20920 영단어 암기는 괴로워](https://www.acmicpc.net/problem/20920)<br>
[백준 2579 계단 오르기](https://www.acmicpc.net/problem/2579)

## **20920 영단어 암기는 괴로워**

### 접근
1. 문제에 있는 우선순위 순서대로 자주 나오는 단어는 딕셔너리로 만들고 그 후에 단어의 길이와 알파벳 사전 순은 sorted, lambda를 사용하여 딕셔너리를 정렬함.
<hr>
```
딕셔너리와 sorted로 여러가지 정렬을 한번에 할 수 있다는 걸 알아서 쉽게 접근하여 풀 수 있었다.
3
```
<br>

## **백준 178870 연속된 부분 수열의 합**

### 접근
1. for 문으로 첫 인덱스부터 시작!
2. 인덱스에 +1을 주면서 k보다 커지거나 인덱스를 넘어가면 종료되는 while 문을 줌
3. while 문안에서 for 문의 시작 지점부터 인덱스를 돌면서 종료되기 전까지 누적 합을 만듦
4. 누적 합의 k랑 같아지고 길이가 더 짧으면 answer 초기화
> 시간 초과.... sequence의 길이가 엄청 길어지면 리스트의 길이만큼 for 문과 while 문을 여러 번 반복하기 때문에 시간 초과가 남

<hr>

### 개선
1. 리스트를 for 문으로 돌지만 전에 코드에선 while 문에서 시간이 많이 소요된 반면에 개선된 코드에선 누적 합의 k보다 커지면 앞의 값부터 차근차근 빼는 코드로 작성돼서 시간 복잡도를 줄임
2. k보다 커지는 경우엔 while 문으로 들어가고 같은 경우엔 if 문으로 길이가 짧을 경우에만 (같은 경우는 앞 쪽 수열이 답이기 때문에 pass) answer 값 초기화를 시켜주는 코드

## 느낀점
1. 문제에서 하라는 대로 단순하게 코드를 짜면 항상 시간 복잡도와 예외 처리에서 걸린다. 하지만 아직 내 능력에선 문제를 그대로 직역해서 코드를 짜고 그다음 예외 처리가 순서인 것 같긴 하다.
2. 이번에는 연속된 수열이기 때문에 인덱스를 +1인 형식으로 할 수 있었다. 저번 백준을 이런 방식으로 풀었기 때문에 그나마 멀리 돌아가지 않고 문제에 접근할 수 있었다.
3. 리스트보단 누적합을 쓰는 경우가 많았다... 시간 복잡도를 위해 sum이나 len은 되도록 지양해야 된다고 느꼈다.


## 방향성
1. 문제에 대해 고민하고 한번 정리한 뒤에 코드를 짜니까 전보다 문제를 이해하는데 더 쉬워진 것 같다.
2. 일단 막히면 한번 글로 정리해 보는 방법으로 하니까 어디서 문젠지, 어떤 방법인지 확실하게 와닿아서 이 방법을 계속 사용해 봐야겠다.



