# 16주차
## 공통 / 개인 문제
> [백준 1463 1로 만들기](https://www.acmicpc.net/problem/1463)<br>
[백준 2747 피보나치 수](https://www.acmicpc.net/problem/2747)

> [백준 1931 전깃줄](https://www.acmicpc.net/problem/1931)


## **📖백준 1463 1로 만들기**

### 접근
1. 3과 2로 나누거나 1을 뺴는 방법으로 주어진 수를 1로 만들어야 한다.
### 코드 설명
1. 2부터 주어진 수까지 반복문을 실행
  - 1로 만들어야 하기에 1은 고려하지 않음
2. 일단 먼저 1을 빼주고 시작
3. if-if문을 써서 현재 자리(1 빼준 상황)의 dp와 3으로 나눈 경우와 2로 나눈 경우 모두를 확인함
  - if - elif일 경우 앞에가 참이면 뒤에 조건문은 더 이상 실행하지 않으므로 사용하면 안됨(12일 경우에는 3으로 나눌 경우와 2로 나눌 경우 둘 다 확인을 해야 함)
4. d리스트는 인덱스 n번째 마다 최소의 이동 횟수 값이 나옴

<br>

## **📖백준 2747 피보나치 수**

### 접근
1. 피보나치 수는 0과 1로 시작 -> 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 
2. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.

### 코드 풀이
1. [0] * n + 1만큼의 리스트를 하나 만든다.
2. 1번째는 1이므로 d[1] = 1로 설정
3. 반복문을 2부터 n까지 돌 수 있게 설정
4. 바로 앞 두 피보나치 수의 합이 된다의 코드 구현은 d[i] = d[i-1] + d[i-2] 이다.


<hr>

## 🌈느낀점
- 알고리즘 초반에 피보나치 수열을 엄청 어렵다고 느꼈는데 dp를 풀고 다시 보니 이렇게 간단해 보일 수가 없다. 
- 하다보면 느는건 당연하지만 실력이 오를 수록 그 위의 실력까지 가기엔 더 많은 노력과 시간이 필요할 것 같다는 생각이 들었다.
- 하지만 그럼에도 불구하고... 직진!

## ✏️방향성
1. 여러 문제를 계속해서 반복적으로 풀어야겠다. 안다고 생각하고 넘기고 다시 돌아가서 문제를 풀려고 하면 새 하얗게 잊어버리는 불상사가 발생한다. 항상 감을 잃지 않게 노력해야겠다.
