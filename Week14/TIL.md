# 14주차
## 공통 문제
> [백준 12904 A와 B](https://www.acmicpc.net/problem/12904)<br>
[백준 20444 색종이와 가위](https://www.acmicpc.net/problem/20444)

## **📖백준 12904 A와 B**

### 접근
1. 만들 수 있는 모든 문자열을 리스트에 넣는다.
  - len으로 1보다 클 경우에는 문자를 뒤집고 B를 뒤에 붙여서 리스트에 넣고,
  - 그렇지 않는 경우와 1보다 클 경우 모두 A를 뒤에 붙여서 리스트에 넣어준다.
  - 이때 T의 문자의 길이보다 길어지는 경우 반복문 종료를 해준다.
  - 만약 그 전에 T와 같은 문자열이 popleft되면 result값을 1로 초기화 해주고 반복문 종료를 한다.
> 처음에 이 방법으로 문자열을 슬라이싱을 통해서 문자열을 뒤집으니, 메모리 초과로 오류가 떴다. 
<br>
그 뒤로, reversed로 뒤집고 B를 붙여주니 시간초과가 떴다. 
<br>
 (겸사겸사 알아보니 문자열 더해주는 문자열이 길 경우 시간 복잡도가 커지니 join을 사용해주라고 했다. 하지만 이 경우에는 B나 A 하나만 더해주기 때문에 문자열이 너무 길어질 경우 시간초과가 난다고 보면 된다.)

### 개선
- 처음엔 문자열을 반대로 뒤집어서 매번 확인하면 시간 복잡도가 너무 높아지기 때문이라고 생각했다. 하지만 그게 아니라 문자가 길어지면 모든 경우의 수를 다 리스트에 넣는게 너무 많아져서 시간초과가 뜬거다.
- **반대로 S를 T로 만들 수 있는지를 확인하면 모든 경우의 수를 확인하지 않기 때문에 문자열이 길어져도 시간 복잡도가 엄청 커지지 않는다.**



<br>

## **📖백준 20444 색종이와 가위**

### 접근
1. 가로로 자르면 가로의 개수만큼 세로로 자르면 세로의 개수만큼 늘어나는 규칙을 알아냈다.
<br>
-> 하지만 이 접근보단...

2. 그냥 가로로 가위질 했으면 가로 개수에 +1해주고 세로로 자르면 세로 개수에 +1해주면 된다.
  - 가로개수 * 세로개수 = 조각의 개수
  - bfs로 모든 경우의 수를 파악하기로 함
  - 리스트에 가로로 잘려지는 경우의 가로,세로,cut개수와 세로로 잘려지는 경우의 가로,세로,cut의 개수를 넣어줌
  - 그리고 popleft 해줬을 때, 문제에 주어진 조각의 개수와 컷팅 개수가 같으면 result를 "YES"로 초기화

>- 범위가 2^63까지 가야히기 때문에... 모든 경우의 수를 따지게 되면 시간 초과가 될 수 밖에 없다.
<br>

> [블로그의 Tip](https://abcdefgh123123.tistory.com/352)
>- 범위가 대놓고 몇억->이분탐색

### 개선
1. 자료의 양이 많으므로 모든 경우의 수를 파악 할 순 없다.
2. 이렇게 자료의 양이 많을 경우에는 이분법으로 나눠서 중간보다 크면 큰 쪽으로 작으면 작은 쪽으로 이동하면서 값을 찾아야 한다.
- 코드 설명
  1. 왼쪽과 오른쪽 포인트를 정한다.
  2. 오른쪽 포인트는 n의 중간값으로 시작한다.
  3. 모든 경우의 수를 탐색하는게 아닌, left와 right 합이 n이 되는 모든 경우의 수를 확인하는 느낌으로 코드를 작성해야 한다.

<hr>


## 🌈느낀점
- A와 B
  1. 항상 코드의 방향을 반대로 생각하면 어떨까...라는 것도 생각해봐야겠다ㅠㅠ
- 색종이와 가위
  1. 범위가 말도 안되게 많으면 이분법을 사용해라
  2. 하지만 아직 이분법이 익숙치 않아서 마음이 좀 찝찝하다.
> 모든 문제는 완전탐색, bfs, dfs로 풀면 된다고 생각했는데 시간 초과나 메모리도 신경 써야 된다고 느꼈다.

## ✏️방향성
1. 이분법을 정리하고, 색종이 문제에서 왜 rowCol을 기준으로 코드를 짰는지 colCut 기준으로 짜면 어떻게 되는지 좀 더 생각해봐야겠다.
2. 이번에 시간 복잡도에 걸려서 찾아본 내용을 따로 정리하자.
