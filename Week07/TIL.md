# 7주차
## 공통 문제
> [백준 2468 안전 영역](https://www.acmicpc.net/problem/2468)<br>
[백준 2667 단지번호붙이기](https://www.acmicpc.net/problem/2667)

## **📖백준 안전 영역**

### 접근
1. 일정 높이 이하로는 모든 지점이 물에 잠기므로 높이에 따라서 물에 잠기는 영역에 개수가 달라진다.<br>
 -> 무조건 낮은 높이가 잠기는 영역이 많지는 않고 2차원 리스트로 각 높이들이 모두 제 각각 다르므로 모든 높이의 경우의 수를 확인한다. (각 지역의 최대 높이까지만 확인하기)
2. 최대 높이까지의 반복문을 돌려서 각 높이에 따른 안정영역의 2차원 리스트를 만들어준다.(영역의 개수를 여기서 초기화 시켜준다)
3. 각 높이의 안전 영역을 돌면서 반복하며 안전한 영역일 경우에 cnt+1 해주고 상,하,좌,우로 돌면서 영역을 확장 해나가고(while로 진행) stack이 비어있으면 한 개의 영역이 끝나므로 while문 종료 시킨다.
4. 그렇게 얻은 cnt를 리스트에 담는다.
5. 담아진 리스트를 최댓값을 구한다. 


<br>

## **📖백준 2667 단지번호붙이기**

### 접근
1. 2차원 리스트로 집이 아닌 경우 0과 집인 경우 1로 나눠, 상,하,좌,우에 집이 붙어 있는 경우 하나의 단지로 정의한다. 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력한다.
2. 2차원 리스트로 지도를 받고 그 리스트를 반복문으로 전체를 돈다.
3. 집인 경우에(1인 경우엔) 다시 그 집을 돌지 않기 위해 0으로 바꿔주고 stack에 담아준다. 또한, 각 영역의 집의 개수를 딕셔너리로 정의 해주기 위해서 result_dict[cnt+1] = 1를 사용한다.
4. while문을 실행하여 상,하,좌,우에서 집인 경우에 stack에 담아주고 그 영역에 집의 개수 +1을 해주기 위해서 result_dict[cnt+1] += 1를 사용하고, 그 부분을 다시 방문하지 않기 위해 0으로 값을 변경해준다. 이 과정을 stack이 빌 때까지 while문으로 진행한다.
5. 딕셔너리로 만들어진 값을 정렬하고 길이와 값을 출력해준다.

<hr>

## 🌈느낀점
1. bfs인지 dfs인지는 잘 모르겠지만, 그래도 처음보다는 많이 익숙해진 기분인다.
2. 모든 경우의 수를 돌면서 조건에 맞는 경우에 몇가지 코드만 추가하면 된다 라는 전체적인 틀은 비슷하기 때문에 점점 익숙해진 것 같다.

## ✏️방향성
1. 어렵다고 겁 먹지 말고 차근 차근 코드를 써내려 가면서 막히는 부분은 글로 적어 천천히 생각하면 생소한 개념 문제가 아닌 경우엔 다 풀린다고 생각해야겠다.



