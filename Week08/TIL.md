# 2주차
## 공통 문제
> [백준 1697 숨바꼭질](https://www.acmicpc.net/problem/1697)<br>
[백준 2638 치즈](https://www.acmicpc.net/problem/2638)

## **📖백준 1697 숨바꼭질**

### 접근
1. while문으로 N과 K의 값이 같아질 경우에 종료
2. 한 번의 While문이 돌 때마다, -1, +1, *2를 하고 K값과의 차이가 값이 가장 적은 값을 K로 바꿔준다. 
### 개선

<br>

## **📖백준 2638 치즈**

### 접근
1. 2차원 리스트로 집이 아닌 경우 0과 집인 경우 1로 나눠, 상,하,좌,우에 집이 붙어 있는 경우 하나의 단지로 정의한다. 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력한다.
2. 2차원 리스트로 지도를 받고 그 리스트를 반복문으로 전체를 돈다.
3. 집인 경우에(1인 경우엔) 다시 그 집을 돌지 않기 위해 0으로 바꿔주고 stack에 담아준다. 또한, 각 영역의 집의 개수를 딕셔너리로 정의 해주기 위해서 result_dict[cnt+1] = 1를 사용한다.
4. while문을 실행하여 상,하,좌,우에서 집인 경우에 stack에 담아주고 그 영역에 집의 개수 +1을 해주기 위해서 result_dict[cnt+1] += 1를 사용하고, 그 부분을 다시 방문하지 않기 위해 0으로 값을 변경해준다. 이 과정을 stack이 빌 때까지 while문으로 진행한다.
5. 딕셔너리로 만들어진 값을 정렬하고 길이와 값을 출력해준다.
<hr>

### 개선


## 🌈느낀점
1. bfs인지 dfs인지는 잘 모르겠지만, 그래도 처음보다는 많이 익숙해진 기분인다.
2. 모든 경우의 수를 돌면서 조건에 맞는 경우에 몇가지 코드만 추가하면 된다 라는 전체적인 틀은 비슷하기 때문에 점점 익숙해진 것 같다.

## ✏️방향성
1. 어렵다고 겁 먹지 말고 차근 차근 코드를 써내려 가면서 막히는 부분은 글로 적어 천천히 생각하면 생소한 개념 문제가 아닌 경우엔 다 풀린다고 생각해야겠다.



