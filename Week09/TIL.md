# 2주차
## 공통 문제
> [백준 16236 아기 상어](https://www.acmicpc.net/problem/16236)<br>
[백준 13717 포켓몬 GO](https://www.acmicpc.net/problem/13717)

## **📖백준 16236 아기 상어**

### 접근
1. 문제
  - 가장 처음 아기 상어의 크기 : 2
  - 1초에 상하좌우로 인접한 한 칸씩 이동 가능
  - 자신보다 큰 물고기가 있으면 지나갈 수 x
  - 아기 상어는 자신보다 작은 크기만 잡아 먹을 수 있음
  - 크기가 같은 물고기는 먹을 수 없지만, 지나갈 수는 있음
  1. 아기 상어는 그래프 전체를 돌면서 물고기를 잡아먹는다.
  2. 먹을 수 있는 물고기가 없으면 엄마 상어에게 도움을 요청
  3. 먹을 수 있는 물고기가 1마리 이상이면 가까운 물고기를 먼저 먹으러 간다.
    - 칸으로 이동, 지나야하는 칸의 개수 최솟값
    - 거리가 가장 가까운 물고기가 많다면 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다.
  - 아기 상어는 자신의 크기와 같은 수의 물고기를 먹으면 크기가 1 증가한다.
  - 몇 초 동안 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있나?

### 코드 방향성
1. 상어의 위치를 찾아서 시작점을 찾는다.
2. While문을 두개를 쓴다.
  1. 상어가 이미 한 움직임으로 먹을 수 있는 물고기가 있는데, 다음 움직임으로 넘어가게 되면 while문을 종료 시킨다. (if count > flag break) (시간 복잡도 최소화 시킴)
  2. 위에 조건에 걸리지 않으면 상하좌우로 돌면서 범위 안에 있고 아직 방문하지 않고, 상어의 사이즈보다 물고기가 크지 않으면 방문리스트를 True로 바꿔주고 q에 좌표와 움직임을 넣어준다.
  3. 다만, 위에 if문에서 상어가 먹을 수 있는 물고기, 즉 상어보다 작은 사이즈의 물고기가 상하좌우로 있을 때만 fish라는 리스트에 좌표와 움직임을 담아준다.
  4. 상하좌우로 더 이상 움직일 곳이 없거나, 1번 조건에서 걸리면 While문이 종료된다.
  5. 종료가 되면 먹을 수 있는 물고기들을 비교할 수 있는데 (이 때 담겨져 있는 물고기들은 모두 움직임이 같다) 가장 위에, 그게 같으면 가장 왼쪽에 있는 위치로 정렬 후에 total_days 움직임을 넣고 그 자리는 0으로 만들어준다.
  6. 물고기를 잡아 먹을 때마다 eat 변수에 +1을 해주고 eat가 상어의 크기와 같아지면 상어의 크기를 1을 더해주고 eat는 0으로 초기화 시켜준다.
  7. 마지막으로 물고기를 잡아먹은 위치로 상어을 이동 시킨다.
  8. 만약 4번 이후로 먹을 수 있는 물고기가 없으면 즉 fish라는 리스트에 아무것도 담기지 않았으면 전체 while문을 종료시킨다.
  
> while문을 두개를 사용하는게 이해가 어려웠다. 각각의 While문이 하는 역할을 완벽히 이해한 후에 모든 코드가 이해가 갔다. 한개의 While문은 dfs로 사용하고 밖에 있는 While문은 상어가 물고기를 잡아 먹으면 다시 그 자리서부터 dfs를 시작해야된다. 라는 부분을 혼자서 과연 문제를 풀 때 생각할 수 있는 때가 올까...😥
<br>

## **📖백준 13717 포켓몬 GO**

### 접근
1. 포켓몬 사탕 M개를 갖고, 진화를 위해 필요한 사탕은 K이다.
2. 진화를 할 때마다 사탕을 +2개씩 준다.

### 개선
1. 처음에는 굳이 반복문을 한번 더 쓰기 싫어서 연산자 //를 이용할려 했지만, 진화를 할 때마다 +2라는 부분이 발목을 잡았다.
2. 그래서 몫만큼 +2씩을 해줬지만 그렇게 되면 마지막에 +2로 진화를 할 수 있는 경우는 헤아리지 못한다.
3. 그래서 While문을 사용하여 M을 K만큼 빼주고 빼줄 때 마다 +2씩을 M에 더해준다.
4. 종료 조건으로 K보다 M이 작아지면이라는 조건을 사용한다.

<hr>


## 🌈느낀점
- 포켓몬 GO
  1. 포켓몬 GO의 문제는 한번 다른 길로 갈려다가 길을 좀 헤맸지만 전체적인 코드를 보면 크게 어려움 없이 이해 할 수 있었다.
- 아기 상어
  1. 아기상어 같은 문제는 문제의 이해부터가 살짝 어려움이 있었다. 또한 코드를 접근하는데 단순히 반복문을 쓰는게 아닌 좀 더 복잡해 보였기 때문에 고민 하다가 코드를 찾아봤다.
  2. 여러가지 코드를 찾아봤지만 함수를 사용하는 코드가 많았는데 개인적으로 함수를 쓰지 않고 풀어보고 싶었고 찾은 코드가 작성한 코드였는데 코드 길이가 너무 길어서 이해하는데 쉽지 않았다.
  3. 이렇게 찾아 본 코드를 이해할 때에 가장 어려운 점은 순서인 것 같다. 무조건 위에서 아래로 코드를 이해할려고 하면, 가장 첫줄에 있는 코드가 제일 먼저 필요한 코드가 아닌 가장 중요한 종료 조건인 경우에는 그걸 먼저 이해할려고 하면 이해가 되지 않는 것 같다.
  4. 그렇기에 그 변수가 어디서 사용 됐는지를 찾아서 꼬리물기로 코드를 이해하다 보면 언젠간 무조건 이해할거라 믿는다.
  5. 이번 문제는 골드 문제답게 푸는데 살짝의 난항을 겪었지만... 막상 이해하고 보니 코드 자체는 그렇게 어렵지 않은 것 같다.
  6. 언젠간 이런 코드를 혼자서 스스로 짤 수 있는 사람이 되고 싶다...

## ✏️방향성
1. 아직까지는 30분 고민 한 뒤 방향성을 찾지 못하면 바로 코드를 찾아보는 방식으로 하고 있는데 이 방식은 예전에 알고리즘을 막 배웠을 때 사용한 것이라 문제의 난이도가 그리 높지 않을 때 사용했는데 지금은 어느 정도 문제의 난이도가 상승했기에, 더 고민을 해볼까 하는 생각이 든다.
2. 위에 방식으로 자꾸 코드를 찾아보면... 조금만 어려운 문제도 바로 코드를 찾아보기 때문에 실력이 늘지 않나 하는 생각이 들어서 더 고민을 해보려고 하지만 고민을 한다고 문제가 풀리진 않고 이렇게 코드를 이해하면서 실력이 늘거라고 살짝의 의심과 함께 일단 계속 풀어나가고 있다.
3. 가장 좋은 방법은 일단 문제를 내 방법으로 간단하게 요약하여 작성 한 뒤에 손 코딩으로 풀다보면 좀 더 쉽게 문제가 풀렸던 적이 있기에 손 코딩으로 문제를 풀어나갈려고 해야겠다.
4. 하지만 위에 방법이 가끔은... 안 맞는 문제가 있다... 그럴 땐 난이도가 너무 높은 문제라고 생각이 들어 코드를 찾아보는 방식으로 해야겠다.
5. 더 좋은 방법이 있지 않을까 하는 의구심이 들기 때문에 좀 더 고민해보자.




